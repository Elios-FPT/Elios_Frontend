[
  {
    "id": 2,
    "title": "Reverse String",
    "difficulty": "Easy",
    "description": "Write a function that reverses a string. The input string is given as an array of characters. Do not allocate extra space for another array; you must do this by modifying the input array in-place with O(1) extra space.",
    "examples": [
      {
        "input": "s = ['h','e','l','l','o']",
        "output": "['o','l','l','e','h']",
        "explanation": "The input string is reversed in-place."
      },
      {
        "input": "s = ['H','a','n','n','a','h']",
        "output": "['h','a','n','n','a','H']",
        "explanation": "The input string is reversed in-place, preserving character case."
      }
    ],
    "constraints": [
      "1 <= s.length <= 10^5",
      "s[i] is a printable ASCII character.",
      "Do not allocate extra space for another array."
    ],
    "topics": ["String", "Two Pointers"],
    "hints": [
      "Consider using two pointers: one starting from the beginning and one from the end.",
      "Swap characters until the pointers meet."
    ]
  },
  {
    "id": 3,
    "title": "Valid Parentheses",
    "difficulty": "Easy",
    "description": "Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. An input string is valid if open brackets are closed by the same type of brackets in the correct order.",
    "examples": [
      {
        "input": "s = '()'",
        "output": "true",
        "explanation": "The string contains a valid pair of parentheses."
      },
      {
        "input": "s = '()[]{}'",
        "output": "true",
        "explanation": "All brackets are properly nested and closed."
      },
      {
        "input": "s = '(]'",
        "output": "false",
        "explanation": "The brackets are not properly closed."
      }
    ],
    "constraints": [
      "1 <= s.length <= 10^4",
      "s consists of parentheses only '()[]{}'."
    ],
    "topics": ["String", "Stack"],
    "hints": [
      "Use a stack to keep track of opening brackets.",
      "Check if each closing bracket matches the most recent opening bracket."
    ]
  },
  {
    "id": 4,
    "title": "Merge Two Sorted Lists",
    "difficulty": "Easy",
    "description": "Merge two sorted linked lists and return it as a new sorted list. The new list should be made by splicing together the nodes of the first two lists.",
    "examples": [
      {
        "input": "list1 = [1,2,4], list2 = [1,3,4]",
        "output": "[1,1,2,3,4,4]",
        "explanation": "The merged list is sorted and contains all elements from both lists."
      },
      {
        "input": "list1 = [], list2 = []",
        "output": "[]",
        "explanation": "Both lists are empty, so the result is empty."
      }
    ],
    "constraints": [
      "The number of nodes in both lists is in the range [0, 50].",
      "-100 <= Node.val <= 100",
      "Both list1 and list2 are sorted in non-decreasing order."
    ],
    "topics": ["Linked List", "Recursion"],
    "hints": [
      "Use a dummy node to simplify the merging process.",
      "Compare nodes from both lists and build the result incrementally."
    ]
  },
  {
    "id": 5,
    "title": "Longest Substring Without Repeating Characters",
    "difficulty": "Medium",
    "description": "Given a string s, find the length of the longest substring without repeating characters.",
    "examples": [
      {
        "input": "s = 'abcabcbb'",
        "output": "3",
        "explanation": "The longest substring is 'abc', with length 3."
      },
      {
        "input": "s = 'bbbbb'",
        "output": "1",
        "explanation": "The longest substring is 'b', with length 1."
      },
      {
        "input": "s = 'pwwkew'",
        "output": "3",
        "explanation": "The longest substring is 'wke', with length 3."
      }
    ],
    "constraints": [
      "0 <= s.length <= 5 * 10^4",
      "s consists of English letters, digits, symbols, and spaces."
    ],
    "topics": ["String", "Sliding Window", "Hash Table"],
    "hints": [
      "Use a sliding window to track the current substring.",
      "Keep a hash map to store the last seen position of each character."
    ]
  },
  {
    "id": 6,
    "title": "Add Two Numbers",
    "difficulty": "Medium",
    "description": "You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each node contains a single digit. Add the two numbers and return the sum as a linked list.",
    "examples": [
      {
        "input": "l1 = [2,4,3], l2 = [5,6,4]",
        "output": "[7,0,8]",
        "explanation": "342 + 465 = 807, so the output is [7,0,8]."
      },
      {
        "input": "l1 = [0], l2 = [0]",
        "output": "[0]",
        "explanation": "0 + 0 = 0."
      }
    ],
    "constraints": [
      "The number of nodes in each linked list is in the range [1, 100].",
      "0 <= Node.val <= 9",
      "The numbers do not contain leading zeros, except for the number 0 itself."
    ],
    "topics": ["Linked List", "Math"],
    "hints": [
      "Handle the carry when the sum of digits exceeds 9.",
      "Use a dummy node to simplify list construction."
    ]
  },
  {
    "id": 7,
    "title": "Container With Most Water",
    "difficulty": "Medium",
    "description": "Given an array of non-negative integers representing the heights of vertical lines, find two lines that together with the x-axis form a container that holds the most water.",
    "examples": [
      {
        "input": "height = [1,8,6,2,5,4,8,3,7]",
        "output": "49",
        "explanation": "The maximum area is formed by lines at indices 1 and 8 (height 8 and 7, width 7)."
      },
      {
        "input": "height = [1,1]",
        "output": "1",
        "explanation": "The area is 1 (height 1, width 1)."
      }
    ],
    "constraints": [
      "2 <= height.length <= 10^5",
      "0 <= height[i] <= 10^4"
    ],
    "topics": ["Array", "Two Pointers"],
    "hints": [
      "Use two pointers to maximize the area by adjusting the width and height.",
      "Move the pointer at the shorter height to potentially increase the area."
    ]
  },
  {
    "id": 8,
    "title": "Maximum Subarray",
    "difficulty": "Medium",
    "description": "Given an integer array nums, find the contiguous subarray with the largest sum and return its sum.",
    "examples": [
      {
        "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
        "output": "6",
        "explanation": "The subarray [4,-1,2,1] has the largest sum 6."
      },
      {
        "input": "nums = [1]",
        "output": "1",
        "explanation": "The subarray [1] has sum 1."
      }
    ],
    "constraints": [
      "1 <= nums.length <= 10^5",
      "-10^4 <= nums[i] <= 10^4"
    ],
    "topics": ["Array", "Dynamic Programming", "Divide and Conquer"],
    "hints": [
      "Consider using Kadane's algorithm to track the maximum sum subarray.",
      "Keep a running sum and reset it when it becomes negative."
    ]
  },
  {
    "id": 9,
    "title": "Binary Tree Inorder Traversal",
    "difficulty": "Medium",
    "description": "Given the root of a binary tree, return the inorder traversal of its nodes' values.",
    "examples": [
      {
        "input": "root = [1,null,2,3]",
        "output": "[1,3,2]",
        "explanation": "Inorder traversal visits left subtree, root, then right subtree."
      },
      {
        "input": "root = []",
        "output": "[]",
        "explanation": "Empty tree returns empty list."
      }
    ],
    "constraints": [
      "The number of nodes in the tree is in the range [0, 100].",
      "-100 <= Node.val <= 100"
    ],
    "topics": ["Tree", "Depth-First Search", "Stack"],
    "hints": [
      "Use recursion or a stack for iterative traversal.",
      "Inorder traversal follows left-root-right order."
    ]
  },
  {
    "id": 10,
    "title": "Word Search",
    "difficulty": "Medium",
    "description": "Given an m x n board of characters and a string word, return true if the word can be found in the grid. The word must be constructed from letters of sequentially adjacent cells (horizontally or vertically), without reusing cells.",
    "examples": [
      {
        "input": "board = [['A','B','C','E'],['S','F','C','S'],['A','D','E','E']], word = 'ABCCED'",
        "output": "true",
        "explanation": "The word 'ABCCED' can be formed by following a path in the board."
      },
      {
        "input": "board = [['A','B','C','E'],['S','F','C','S'],['A','D','E','E']], word = 'ABCB'",
        "output": "false",
        "explanation": "The word 'ABCB' cannot be formed without reusing cells."
      }
    ],
    "constraints": [
      "m == board.length",
      "n == board[i].length",
      "1 <= m, n <= 6",
      "1 <= word.length <= 15",
      "board and word consist of uppercase and lowercase English letters."
    ],
    "topics": ["Backtracking", "Matrix"],
    "hints": [
      "Use backtracking to explore all possible paths.",
      "Mark visited cells to avoid reuse."
    ]
  },
  {
    "id": 11,
    "title": "Longest Palindromic Substring",
    "difficulty": "Hard",
    "description": "Given a string s, return the longest palindromic substring in s.",
    "examples": [
      {
        "input": "s = 'babad'",
        "output": "'bab'",
        "explanation": "'aba' is also valid, but 'bab' is equally long."
      },
      {
        "input": "s = 'cbbd'",
        "output": "'bb'",
        "explanation": "The longest palindromic substring is 'bb'."
      }
    ],
    "constraints": [
      "1 <= s.length <= 1000",
      "s consists of lowercase or uppercase English letters."
    ],
    "topics": ["String", "Dynamic Programming", "Manacher's Algorithm"],
    "hints": [
      "Consider expanding around the center for each position.",
      "Alternatively, use dynamic programming to track palindromic substrings."
    ]
  }
]